package hr.fer.zemris.java.hw04.lexer;

import hr.fer.zemris.java.hw04.db.QueryParser;

/**
 * Lexer that performs lexer analysis on given string. Generates tokens for
 * {@link QueryParser}. Tokens that begin with letter and aren't AND or LIKE
 * operators are considered attribute names. Tokens that begin with quotes are
 * considered string literals. Tokens that begin with any operator are
 * considered as conditional operators. Strings AND and LIKE are also considered
 * operators.
 * 
 * @author Mihael JaiÄ‡
 *
 */

public class QueryLexer {
	/**
	 * Input string.
	 */
	private String data;
	/**
	 * Token.
	 */
	private QueryToken token;
	/**
	 * Current index in input string.
	 */
	private int currentIndex;

	/**
	 * Constructor that gets input string.
	 * 
	 * @param data
	 *            Input string.
	 * @throws IllegalArgumentException
	 */

	public QueryLexer(String data) throws IllegalArgumentException {
		super();
		if (data == null) {
			throw new IllegalArgumentException("Input string can't be null.");
		}

		this.data = data;
	}

	/**
	 * Gets next token.
	 * 
	 * @return Next token.
	 * @throws IllegalStateException
	 *             If end of file was reached before this call.
	 */

	public QueryToken nextToken() throws IllegalStateException {
		if (token != null && token.getType() == QueryTokenType.EOF) {
			throw new IllegalStateException("Reached end of file.");
		}

		generateToken();
		return token;
	}

	/**
	 * Gets last token generated by lexer.
	 * 
	 * @return Last token generated by lexer.
	 * @throws IllegalStateException
	 *             If no tokens were generated yet.
	 */

	public QueryToken getToken() throws IllegalStateException {
		if (token == null) {
			throw new IllegalStateException("No tokens were generated yet");
		}

		return token;
	}

	/**
	 * Sets new input string.
	 * 
	 * @param data
	 *            New string.
	 */

	public void setData(String data) {
		if (data == null) {
			throw new IllegalArgumentException();
		}

		this.data = data;
		currentIndex = 0;
		token = null;
	}

	/**
	 * Generates new token.
	 */

	private void generateToken() {
		skipSpaces();

		if (currentIndex == data.length()) {
			token = new QueryToken(QueryTokenType.EOF, null);
			return;
		}

		if (isOperator()) {
			token = new QueryToken(QueryTokenType.OPERATOR, generateOperator());

		} else if (isAnd()) {
			token = new QueryToken(QueryTokenType.AND, "AND");
			currentIndex += 3;

		} else if (isStringLiteral()) {
			token = new QueryToken(QueryTokenType.STRING_LITERAL, generateStringLiteral());

		} else if (Character.isLetter(data.charAt(currentIndex))) {
			token = new QueryToken(QueryTokenType.ATTRIBUTE, generateAttribute());

		} else {
			throw new IllegalArgumentException("Invalid command.");
		}
	}

	/**
	 * Skips all space, tab and new line characters.
	 */

	private void skipSpaces() {
		while (currentIndex < data.length() && (data.charAt(currentIndex) == ' ' || data.charAt(currentIndex) == '\n'
				|| data.charAt(currentIndex) == '\t' || data.charAt(currentIndex) == 'r')) {
			currentIndex++;
		}
	}

	/**
	 * Checks if operator and is next in string.
	 * 
	 * @return True if operator and is next, false otherwise.
	 */

	private boolean isAnd() {
		if (currentIndex + 2 >= data.length()) {
			return false;
		}

		String subString = data.substring(currentIndex, currentIndex + 3).toUpperCase();
		return subString.equals("AND");
	}

	/**
	 * Checks if conditional operator is next in string.
	 * 
	 * @return True if conditional operator is next, false otherwise.
	 */

	private boolean isOperator() {
		boolean isSign = data.charAt(currentIndex) == '<' || data.charAt(currentIndex) == '>'
				|| data.charAt(currentIndex) == '=' || (currentIndex + 1 < data.length()
						&& data.charAt(currentIndex) == '!' && data.charAt(currentIndex + 1) == '=');

		boolean isLike = false;
		if (currentIndex + 3 < data.length()) {
			String subString = data.substring(currentIndex, currentIndex + 4).toUpperCase();
			isLike = subString.equals("LIKE");
		}

		return isSign || isLike;
	}

	/**
	 * Checks if string literal is ahead.
	 * 
	 * @return True if string literal is next, false otherwise.
	 */

	private boolean isStringLiteral() {
		return data.charAt(currentIndex) == '\"';
	}

	/**
	 * Generates conditional operator.
	 * 
	 * @return Conditional operator.
	 */

	private String generateOperator() {
		if (data.charAt(currentIndex) == '<' || data.charAt(currentIndex) == '>') {
			if (currentIndex + 1 < data.length() && data.charAt(currentIndex + 1) == '=') {
				currentIndex += 2;
				return data.substring(currentIndex - 2, currentIndex);
			} else {
				currentIndex++;
				return String.valueOf(data.charAt(currentIndex - 1));
			}

		} else if (data.charAt(currentIndex) == '=') {
			currentIndex++;
			return "=";

		} else if (data.charAt(currentIndex) == '!') {
			currentIndex += 2;
			return "!=";

		} else {
			currentIndex += 4;
			return "LIKE";
		}
	}

	/**
	 * Generates string literal.
	 * 
	 * @return String literal.
	 */

	private String generateStringLiteral() {
		StringBuilder sb = new StringBuilder();
		currentIndex++;

		while (currentIndex < data.length() && data.charAt(currentIndex) != '\"') {
			sb.append(data.charAt(currentIndex));
			currentIndex++;
		}
		currentIndex++;

		return sb.toString();
	}

	/**
	 * Generates attribute name.
	 * 
	 * @return Attribute name.
	 */

	private String generateAttribute() {
		StringBuilder sb = new StringBuilder();

		while (currentIndex < data.length() && Character.isLetter(data.charAt(currentIndex))) {
			sb.append(data.charAt(currentIndex));
			currentIndex++;
		}

		return sb.toString();
	}
}
