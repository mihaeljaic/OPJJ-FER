package hr.fer.zemris.java.custom.scripting.exec;

import java.io.IOException;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.EmptyStackException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;
import java.util.function.BiFunction;

import hr.fer.zemris.java.custom.scripting.elems.Element;
import hr.fer.zemris.java.custom.scripting.elems.ElementConstantDouble;
import hr.fer.zemris.java.custom.scripting.elems.ElementConstantInteger;
import hr.fer.zemris.java.custom.scripting.elems.ElementString;
import hr.fer.zemris.java.custom.scripting.elems.ElementVariable;
import hr.fer.zemris.java.custom.scripting.nodes.DocumentNode;
import hr.fer.zemris.java.custom.scripting.nodes.EchoNode;
import hr.fer.zemris.java.custom.scripting.nodes.ForLoopNode;
import hr.fer.zemris.java.custom.scripting.nodes.INodeVisitor;
import hr.fer.zemris.java.custom.scripting.nodes.TextNode;
import hr.fer.zemris.java.custom.scripting.parser.SmartScriptParser;
import hr.fer.zemris.java.webserver.RequestContext;

/**
 * Class that executes script that was generated by {@link SmartScriptParser}
 * and is in form of {@link DocumentNode}. Result of script is written to
 * requested context {@link RequestContext}.
 * 
 * @author Mihael JaiÄ‡
 *
 */

public class SmartScriptEngine {
	/**
	 * Document node.
	 */
	private DocumentNode documentNode;
	/**
	 * Request context.
	 */
	private RequestContext requestContext;
	/**
	 * Multistack used for
	 */
	private ObjectMultistack multistack = new ObjectMultistack();
	/**
	 * Binary operations.
	 */
	private static final Map<String, BiFunction<Double, Double, Double>> binaryOperations;

	static {
		binaryOperations = new HashMap<>();

		binaryOperations.put("+", (a, b) -> a + b);
		binaryOperations.put("-", (a, b) -> a - b);
		binaryOperations.put("*", (a, b) -> a * b);
		binaryOperations.put("/", (a, b) -> a / b);
	}

	/**
	 * Constructor that gets document node and reference to request context that
	 * will be used to write scripts echo commands.
	 * 
	 * @param documentNode
	 *            Document node.
	 * @param requestContext
	 *            Request context.
	 * @throws IllegalArgumentException
	 *             If document node or request context are null.
	 */

	public SmartScriptEngine(DocumentNode documentNode, RequestContext requestContext) throws IllegalArgumentException {
		if (documentNode == null || requestContext == null) {
			throw new IllegalArgumentException();
		}

		this.documentNode = documentNode;
		this.requestContext = requestContext;
	}

	/**
	 * Executes given script from document node.
	 * 
	 * @throws NumberFormatException
	 *             If there was error while converting numbers.
	 * @throws RuntimeException
	 *             If invalid parameters were given to script functions.
	 * @throws EmptyStackException
	 *             If there were invalid amount of parameters for script
	 *             functions.
	 * @throws IOException
	 *             If there was I/O exception.
	 */

	public void execute() throws NumberFormatException, RuntimeException, EmptyStackException, IOException {
		documentNode.accept(visitor);
	}

	/**
	 * Visitor that visits all nodes from document node. And executes commands.
	 */

	private INodeVisitor visitor = new INodeVisitor() {
		private static final double epsilon = 1e-9;

		@Override
		public void visitTextNode(TextNode node) throws IOException {
			requestContext.write(node.getText());
		}

		@Override
		public void visitForLoopNode(ForLoopNode node) throws NumberFormatException, RuntimeException, IOException {
			Object startValue = getValue(node.getStartExpression());
			Object endValue = getValue(node.getEndExpression());
			Object stepValue = node.getStepExpression() == null ? null : getValue(node.getStepExpression());

			boolean startIsInt = startValue instanceof Integer;
			boolean endIsInt = endValue instanceof Integer;
			boolean stepIsInt = stepValue == null || stepValue instanceof Integer;

			int intCounter = startIsInt ? (Integer) startValue : 0;
			int intCondition = endIsInt ? (Integer) endValue : 0;
			int intIncrement = !stepIsInt || stepValue == null ? 1 : (Integer) stepValue;

			double doubleCounter = startIsInt ? 0.0 : (Double) startValue;
			double doubleCondition = endIsInt ? 0.0 : (Double) endValue;
			double doubleIncrement = stepIsInt ? 0.0 : (Double) stepValue;

			String variable = node.getVariable().getName();
			if (startIsInt) {
				multistack.push(variable, new ValueWrapper(intCounter));
			} else {
				multistack.push(variable, new ValueWrapper(doubleCounter));
			}
			while ((startIsInt ? intCounter : doubleCounter) <= (endIsInt ? intCondition : doubleCondition)) {
				for (int j = 0, numOfChildren = node.numberOfChildren(); j < numOfChildren; j++) {
					node.getChild(j).accept(this);
				}

				if (startIsInt) {
					intCounter += (stepIsInt ? intIncrement : doubleIncrement);
					multistack.peek(variable).setValue(intCounter);

				} else {
					doubleCounter += (stepIsInt ? intIncrement : doubleIncrement);
					multistack.peek(variable).setValue(doubleCounter);
				}

			}

			multistack.pop(variable);
		}

		private Object getValue(Element element) {
			if (element instanceof ElementVariable) {
				ValueWrapper wrapper = multistack.peek(((ElementVariable) element).getName());
				if (wrapper == null) {
					throw new RuntimeException(
							String.format("Unknown variable name: %s.%n", ((ElementVariable) element).getName()));
				}

				return wrapper.getValue();
			}

			if (isInteger(element)) {
				return getInteger(element);
			}

			return getDouble(element);
		}

		private int getInteger(Element element) {
			if (element instanceof ElementString) {
				return Integer.parseInt(((ElementString) element).getValue());
			}

			return ((ElementConstantInteger) element).getValue();
		}

		private double getDouble(Element element) {
			if (element instanceof ElementString) {
				return Double.parseDouble(((ElementString) element).getValue());
			}

			return ((ElementConstantDouble) element).getValue();
		}

		private boolean isInteger(Element element) {
			if (element instanceof ElementConstantInteger) {
				return true;
			}

			if (!(element instanceof ElementString)) {
				return false;
			}

			String value = ((ElementString) element).getValue();
			return !value.contains(".") && !value.toUpperCase().contains("E");
		}

		@Override
		public void visitEchoNode(EchoNode node) throws IOException {
			Stack<Object> tempStack = new Stack<>();

			for (Element element : node.getElements()) {
				if (element instanceof ElementConstantInteger) {
					tempStack.push(((ElementConstantInteger) element).getValue());
				} else if (element instanceof ElementConstantDouble) {
					tempStack.push(((ElementConstantDouble) element).getValue());
				} else if (element instanceof ElementString) {
					tempStack.push(((ElementString) element).getValue());
				} else if (element instanceof ElementVariable) {
					tempStack.push(getValue(element));
				} else {
					performOperation(element.asText(), tempStack);
				}
			}

			writeContext(tempStack);
		}

		private void writeContext(Stack<Object> tempStack) throws IOException {
			List<String> text = new ArrayList<>();
			while (!tempStack.isEmpty()) {
				text.add(tempStack.pop().toString());
			}

			StringBuilder sb = new StringBuilder();
			for (int i = text.size() - 1; i >= 0; i--) {
				sb.append(text.get(i));
			}

			if (!sb.toString().trim().isEmpty()) {
				requestContext.write(sb.toString());
			}
		}

		private void performOperation(String key, Stack<Object> tempStack) {
			if (binaryOperations.containsKey(key)) {
				binaryOperation(key, tempStack);
			} else if (key.equals("sin")) {
				calculateSinus(tempStack);
			} else if (key.equals("decfmt")) {
				decimalFormat(tempStack);
			} else if (key.equals("dup")) {
				tempStack.push(tempStack.peek());
			} else if (key.equals("swap")) {
				swap(tempStack);
			} else if (key.equals("setMimeType")) {
				setMimeType(tempStack);
			} else if (key.equals("paramGet")) {
				paramGet(tempStack);
			} else if (key.equals("pparamGet")) {
				pparamGet(tempStack);
			} else if (key.equals("pparamSet")) {
				pparamSet(tempStack);
			} else if (key.equals("pparamDel")) {
				pparamDel(tempStack);
			} else if (key.equals("tparamGet")) {
				tparamGet(tempStack);
			} else if (key.equals("tparamSet")) {
				tparamSet(tempStack);
			} else if (key.equals("tparamDel")) {
				tparamDel(tempStack);
			} else {
				throw new RuntimeException(String.format("Invalid expression %s.", key));
			}

		}

		private void tparamDel(Stack<Object> tempStack) {
			Object name = tempStack.pop();
			if (!(name instanceof String)) {
				throw new RuntimeException("Name parameter in tparamDel function has to be string.");
			}

			requestContext.removeTemporaryParameter((String) name);
		}

		private void tparamSet(Stack<Object> tempStack) {
			Object name = tempStack.pop();
			Object value = tempStack.pop();

			if (!(name instanceof String)) {
				throw new RuntimeException("Name parameter in tparamSet function has to be string.");
			}

			requestContext.setTemporaryParameter((String) name, value.toString());
		}

		private void tparamGet(Stack<Object> tempStack) {
			Object defaultValue = tempStack.pop();
			Object name = tempStack.pop();

			if (!(name instanceof String)) {
				throw new RuntimeException("Name parameter in tparamGet function has to be string.");
			}

			String value = requestContext.getTemporaryParameter(name.toString());
			tempStack.push(value == null ? defaultValue.toString() : value);
		}

		private void pparamDel(Stack<Object> tempStack) {
			Object name = tempStack.pop();
			if (!(name instanceof String)) {
				throw new RuntimeException("Name parameter in pparamDel function has to be string.");
			}

			requestContext.removePersistentParameter((String) name);
		}

		private void pparamSet(Stack<Object> tempStack) {
			Object name = tempStack.pop();
			Object value = tempStack.pop();

			if (!(name instanceof String)) {
				throw new RuntimeException("Name parameter in pparamSet function has to be string.");
			}

			requestContext.setPersistentParameter((String) name, value.toString());
		}

		private void pparamGet(Stack<Object> tempStack) {
			Object defaultValue = tempStack.pop();
			Object name = tempStack.pop();

			if (!(name instanceof String)) {
				throw new RuntimeException("Name parameter in pparamGet function has to be string.");
			}

			String value = requestContext.getPersistentParameter((String) name);
			tempStack.push(value == null ? defaultValue : value);
		}

		private void paramGet(Stack<Object> tempStack) {
			Object defaultValue = tempStack.pop();
			Object name = tempStack.pop();

			if (!(name instanceof String)) {
				throw new RuntimeException("Name parameter in paramGet function has to be string.");
			}

			String value = requestContext.getParameter((String) name);
			tempStack.push(value == null ? defaultValue : value);
		}

		private void setMimeType(Stack<Object> tempStack) {
			Object mimeType = tempStack.pop();
			if (!(mimeType instanceof String)) {
				throw new RuntimeException("Function setMimeType requests string as argument");
			}

			requestContext.setMimeType((String) mimeType);
		}

		private void swap(Stack<Object> tempStack) {
			Object a = tempStack.pop();
			Object b = tempStack.pop();

			tempStack.push(a);
			tempStack.push(b);
		}

		private void decimalFormat(Stack<Object> tempStack) {
			Object format = tempStack.pop();
			Double value = convertToDouble(tempStack.pop());

			DecimalFormat df = new DecimalFormat(format.toString());

			tempStack.push(df.format(Math.abs(value - value.intValue()) < epsilon ? value.intValue() : value));
		}

		private void calculateSinus(Stack<Object> tempStack) {
			Double x = convertToDouble(tempStack.pop());
			Double result = Math.sin(x * Math.PI / 180);
			if (Math.abs(result - result.intValue()) < epsilon) {
				tempStack.push(result.intValue());
			} else {
				tempStack.push(result);
			}
		}

		private void binaryOperation(String key, Stack<Object> tempStack) {
			Double value1 = convertToDouble(tempStack.pop());
			Double value2 = convertToDouble(tempStack.pop());

			Double result = binaryOperations.get(key).apply(value1, value2);

			if (Math.abs(result - result.intValue()) < epsilon) {
				tempStack.push(result.intValue());
			} else {
				tempStack.push(result);
			}
		}

		private Double convertToDouble(Object temp) {
			if (temp instanceof String) {
				return Double.parseDouble((String) temp);
			}
			if (temp instanceof Double) {
				return (Double) temp;
			}

			return ((Integer) temp).doubleValue();
		}

		@Override
		public void visitDocumentNode(DocumentNode node) throws IOException {
			for (int i = 0, numberOfChildren = node.numberOfChildren(); i < numberOfChildren; i++) {
				node.getChild(i).accept(this);
			}
		}

	};

}
